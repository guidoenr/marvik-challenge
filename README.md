
# Marvik challenge by @guidoenr

> [!WARNING]
> Este proyecto fue testeado en Kali Linux 2024 (Debian-based linux). \
> No se hicieron pruebas en O.S como Windows/MacOS. \
> De todas formas, **no** deberian existir problemas dado que todo vive en una imagen de docker.

## Descripción
Este proyecto resuelve el enunciado recibido por mail usando tecnologias como Docker, Makefile, PostgreSQL para los datos, y Golang para el server.

## Setup / Requisitos
Para poder correr la aplicación, debes tener instalado lo siguiente:

- [**Docker**](https://www.docker.com/)
- [**Make**](https://www.geeksforgeeks.org/how-to-install-make-on-ubuntu/)


## Usage / Correr la aplicación
1. clonar este repositorio
```git
git clone https://github.com/guidoenr/marvik-challenge
```

2. correr la app
```make
make build run
```
luego esperar a que la api este lista, donde se verá en la terminal algo como:
```python
=====================================
   Marvik Challenge by @guidoenr     
=====================================
2025-01-15T13:24:55Z INF APi is ready !
2025-01-15T13:24:55Z INF checkout README.md for further details on usage :)
-----------------
2025-01-15T13:24:55Z INF endpoints:
2025-01-15T13:24:55Z INF http://localhost:8080/users
2025-01-15T13:24:55Z INF http://localhost:8080/organizations
2025-01-15T13:24:55Z INF http://localhost:8080/counters
2025-01-15T13:24:55Z INF http://localhost:8080/
```

> algunas instrucciones extras que podrian ser de utilidad:

**limpiar containers/imagenes** 📌 (*opcional*):
```bash
make clean
```

**entrar al container** 📌 (*opcional*) :
```bash
make exec
```

## Endpoints
debajo se encuentra el listado con todos los endpoints disponibles en la API, con ejemplos de responses/requests en cada una.

### 1. **`GET /`**
lo que podria llamarse el home page -- retorna solamente un mensaje diciendo que esta ready.
```bash
curl -X GET http://localhost:8080/
```

```json
{
  "status": "ready"
}
```

### 2. **`GET /users`**
todos los usuarios y la lista de organizaciones a las que este pertenecen.

> [!TIP]
> este endpoint tiene la capacidad de recibir **filtros** en forma de `QueryParams`

por ejemplo:
```bash
curl -X GET "http://localhost:8080/users?name=Guido"
curl -X GET "http://localhost:8080/users?organization=Veritone"
curl -X GET "http://localhost:8080/users?email=john.doe@example.com"
curl -X GET "http://localhost:8080/users?name=John&surname=Doe&email=@john.doe@example.com"
```


```bash
curl -X GET "http://localhost:8080/users?name=Guido"
```

```json
[
  {
    "id": 1,
    "name": "Guido",
    "surname": "Enrique",
    "email": "guidoenr4@gmail.com",
    "organizations": [
      {
        "id": 1,
        "name": "Veritone"
      }
    ]
  }
]
```

### 3. **`GET /organizations`**
todas las organizaciones y la lista de usuarios que estan dentro de las mismas.
```bash
curl -X GET http://localhost:8080/organizations
```

```json
[
  {
    "id": 1,
    "name": "Veritone",
    "users": [
      {
        "id": 1,
        "name": "Guido",
        "surname": "Enrique",
        "email": "guidoenr4@gmail.com"
      }
    ]
  }
]
```

### 4. **`GET /counters`**
un mapa de contadores para cada endpoint disponible.
> *(el propio endpoint `/counters` tambien tiene un contador y es actualizado al actualizar la pagina)*

```bash
curl -X GET http://localhost:8080/counters
```
```json
{
  "/": 10,
  "/users": 5,
  "/counters": 2,
  "/organizations": 3
}
```

## DB Schema

El esquema de la base de datos contiene dos tablas principales: 

**Usuarios** y **Organizaciones**, con una relación de muchos a muchos entre ellas (*y obviamente la tabla intermedia para JOINS*)

```
users
-----------------------------------------------
| id | name  | surname  | email                |
-----------------------------------------------
| 1  | John   | Doe     | john.doe@example.com |
-----------------------------------------------
| 2  | Guido  | Enrique | guidoenr4@gmail.com  |
-----------------------------------------------
... and more..

organizations
--------------------
| id   | name      |
--------------------
| 1    | Veritone  |
--------------------
| 2    | Slingr    |
--------------------
... and more

user_organizations (generated by `gorm` many2many)
-----------------------------
| user_id | organization_id |
-----------------------------
| 1       | 1               |
-----------------------------
```

Las mismas son inicializadas al iniciar el container con data de ejemplo, valiendose de [init.sql](https://github.com/guidoenr/marvik-challenge/blob/master/init.sql).

## Testing
existe la capacidad de correr tests, haciendo:
```bash
make test
```

esto iniciara las pruebas y verificará que todo funcione correctamente. 

> [!IMPORTANT]
> El server debe estar corriendo (`:8080`) para ejecutar las pruebas.
> dado que estas hacen request literales a los endpoints reales.
> (de todas formas los tests no se ejecutaran si la API no esta levantada)


#### Enunciado
```
Implementar una API en Golang que:

a) se comunique con una base de datos (a elección) que tenga una tabla de usuarios con por lo menos los campos nombre, apellido y mail del usuario

b) reciba un request que tenga filtros de búsqueda sobre la tabla usuarios y devuelva la lista de usuarios que cumplen con el criterio de búsqueda, paginando en el backend

c) reciba un request GET que obtenga el valor de un contador de veces que fue llamado alguno de los endpoints disponibles

d) cada 5 minutos incremente un segundo contador e imprima su valor a un log o consola

Compartir también el esquema de la base de datos. Te pedimos que el código lo compartas con Github en un repositorio privado compartiendo el código al usuario PeopleMarvik o simplemente como archivos adjuntos. Dejar en el README instrucciones para correr la API localmente y/o en un server en producción.

Nice to have:

Permitir que los usuarios puedan pertenecer a una o múltiples organizaciones y en el request de búsqueda de usuarios devolver la lista de organizaciones a las que pertenece el usuario
```