
# marvik-challenge by @guidoenr

> [!WARNING]
> Este proyecto fue testeado en Kali Linux 2024 (Debian-based linux).
> No se hicieron pruebas en O.S como Windows/MacOS.
> No deberian existir problemas dado que todo vive en una imagen de docker.

## Descripción
este proyecto resuelve el enunciado recibido por mail usando tecnologias como Docker, Makefile, PostgreSQL para los datos, y Golang para el server.

## Requisitos
para poder correr la aplicación, deberias tener instalado lo siguiente:

- [**Docker**](https://www.docker.com/)
- [**Make**](https://www.geeksforgeeks.org/how-to-install-make-on-ubuntu/)


## Correr la aplicación
podes ejecutar todo con un solo comando:

```shell
make build run
```
y esperar a que la api este lista, donde veras en la terminal algo como:
```shell
=====================================
   Marvik Challenge by @guidoenr     
=====================================
2025-01-15T13:24:55Z INF APi is ready !
2025-01-15T13:24:55Z INF checkout README.md for further details on usage :)
-----------------
2025-01-15T13:24:55Z INF endpoints:
2025-01-15T13:24:55Z INF http://localhost:8080/users
2025-01-15T13:24:55Z INF http://localhost:8080/organizations
2025-01-15T13:24:55Z INF http://localhost:8080/counters
2025-01-15T13:24:55Z INF http://localhost:8080/
```

O en caso de que querer hacer el paso-a-paso, puedes:

1. **construir la imagen de Docker**:
   ```bash
   make build
   ```

2. **iniciar el container**:
   ```bash
   make run
   ```

3. (📌 optional) **limpiar containers/imagenes**:
   ```bash
   make clean
   ```


4. (📌 optional) **entrar al container**:
   ```bash
   make exec
   ```
   
## Endpoints
debajo esta el listado de todos los endpoints disponible para la API con ejemplos de respuestas al acceder.

### 1. **`GET /`**
lo que podria llamarse el home page de la api, retorna solamente un mensaje diciendo que esta ready.
```bash
curl -X GET http://localhost:8080/
```

```json
{
  "status": "ready"
}
```

### 2. **`GET /users`**
todos los usuarios y la lista de organizaciones a las que pertenecen.

> [!IMPORTANT]
> este endpoint tiene la capacidad de recibir **filtros** en forma de QueryParams

por ejemplo:
```bash
curl -X GET "http://localhost:8080/users?name=Guido"
curl -X GET "http://localhost:8080/users?organization=Veritone"
curl -X GET "http://localhost:8080/users?email=john.doe@example.com"
curl -X GET "http://localhost:8080/users?name=John&surname=Doe&email=@john.doe@example.com"
```


```bash
curl -X GET "http://localhost:8080/users?name=Guido&"
```

```json
[
  {
    "id": 1,
    "name": "Guido",
    "surname": "Enrique",
    "email": "guidoenr4@gmail.com",
    "organizations": [
      {
        "id": 1,
        "name": "Veritone"
      }
    ]
  }
]
```

### 3. **`GET /organizations`**
todas las organizaciones y la lista de usuarios que estan dentro.
```bash
curl -X GET http://localhost:8080/organizations
```

```json
[
  {
    "id": 1,
    "name": "Veritone",
    "users": [
      {
        "id": 1,
        "name": "Guido",
        "surname": "Enrique",
        "email": "guidoenr4@gmail.com"
      }
    ]
  }
]
```

### 4. **`GET /counters`**
un mapa de contadores por aca endpoint disponible.
> (el propio endpoint `/counters` tambien tiene un contador y es actualizado)

```bash
curl -X GET http://localhost:8080/counters
```
```json
{
  "/": 10,
  "/users": 5,
  "/counters": 2,
  "/organizations": 3
}
```

## DB Schema

el esquema de la base de datos contiene dos tablas principales: **Usuarios** y **Organizaciones**, con una relación de muchos a muchos entre ellas.

```
users
-----------------------------------------------
| id | name  | surname  | email                |
-----------------------------------------------
| 1  | John   | Doe     | john.doe@example.com |
-----------------------------------------------
| 2  | Guido  | Enrique | guidoenr4@gmail.com  |
-----------------------------------------------
... and more..

organizations
--------------------
| id   | name      |
--------------------
| 1    | Veritone  |
--------------------
| 2    | Slingr    |
--------------------
... and more

user_organizations (generated by `gorm` many2many)
-----------------------------
| user_id | organization_id |
-----------------------------
| 1       | 1               |
-----------------------------
```

## Testing
existe la capacidad de correr tests, haciendo:
```bash
make test
```

esto iniciara las pruebas y verificará que todo funcione correctamente. 

> [!IMPORTANT]
> El server debe estar corriendo (`:8080`) para ejecutar las pruebas.
> dado que estas hacen request literales a los endpoints reales.
> (de todas formas los tests no se ejecutaran si la API no esta levantada)


### Enunciado
```
Implementar una API en Golang que:

a) se comunique con una base de datos (a elección) que tenga una tabla de usuarios con por lo menos los campos nombre, apellido y mail del usuario

b) reciba un request que tenga filtros de búsqueda sobre la tabla usuarios y devuelva la lista de usuarios que cumplen con el criterio de búsqueda, paginando en el backend

c) reciba un request GET que obtenga el valor de un contador de veces que fue llamado alguno de los endpoints disponibles

d) cada 5 minutos incremente un segundo contador e imprima su valor a un log o consola

Compartir también el esquema de la base de datos. Te pedimos que el código lo compartas con Github en un repositorio privado compartiendo el código al usuario PeopleMarvik o simplemente como archivos adjuntos. Dejar en el README instrucciones para correr la API localmente y/o en un server en producción.

Nice to have:

Permitir que los usuarios puedan pertenecer a una o múltiples organizaciones y en el request de búsqueda de usuarios devolver la lista de organizaciones a las que pertenece el usuario
```