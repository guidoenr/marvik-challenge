
# Marvik challenge by @guidoenr

> [!WARNING]
> Este proyecto fue testeado en Kali Linux 2024 (Debian-based linux). \
> No se hicieron pruebas en O.S como Windows/MacOS. \
> De todas formas, **no** deberian existir problemas dado que todo vive en una imagen de docker.

## Descripci贸n
Este proyecto resuelve el enunciado recibido por mail usando tecnologias como Docker, Makefile, PostgreSQL para los datos, y Golang para el server.

## Setup / Requisitos
Para poder correr la aplicaci贸n, debes tener instalado lo siguiente:

- [**Docker**](https://www.docker.com/)
- [**Make**](https://www.geeksforgeeks.org/how-to-install-make-on-ubuntu/)


## Usage / Correr la aplicaci贸n
1. clonar este repositorio
```git
git clone https://github.com/guidoenr/marvik-challenge
```

2. correr la app
```make
make build run
```
luego esperar a que la api este lista, donde se ver谩 en la terminal algo como:
```python
=====================================
   Marvik Challenge by @guidoenr     
=====================================
2025-01-15T13:24:55Z INF APi is ready !
2025-01-15T13:24:55Z INF checkout README.md for further details on usage :)
-----------------
2025-01-15T13:24:55Z INF endpoints:
2025-01-15T13:24:55Z INF http://localhost:8080/users
2025-01-15T13:24:55Z INF http://localhost:8080/organizations
2025-01-15T13:24:55Z INF http://localhost:8080/counters
2025-01-15T13:24:55Z INF http://localhost:8080/
```

> algunas instrucciones extras que podrian ser de utilidad:

**limpiar containers/imagenes**  (*opcional*):
```bash
make clean
```

**entrar al container**  (*opcional*) :
```bash
make exec
```

## Endpoints
debajo se encuentra el listado con todos los endpoints disponibles en la API, con ejemplos de responses/requests en cada una.

### 1. **`GET /`**
lo que podria llamarse el home page -- retorna solamente un mensaje diciendo que esta ready.
```bash
curl -X GET http://localhost:8080/
```

```json
{
  "status": "ready"
}
```

### 2. **`GET /users`**
todos los usuarios y la lista de organizaciones a las que este pertenecen.

> [!TIP]
> este endpoint tiene la capacidad de recibir **filtros** en forma de `QueryParams`

por ejemplo:
```bash
curl -X GET "http://localhost:8080/users?name=Guido"
curl -X GET "http://localhost:8080/users?organization=Veritone"
curl -X GET "http://localhost:8080/users?email=john.doe@example.com"
curl -X GET "http://localhost:8080/users?name=John&surname=Doe&email=@john.doe@example.com"
```


```bash
curl -X GET "http://localhost:8080/users?name=Guido"
```

```json
[
  {
    "id": 1,
    "name": "Guido",
    "surname": "Enrique",
    "email": "guidoenr4@gmail.com",
    "organizations": [
      {
        "id": 1,
        "name": "Veritone"
      }
    ]
  }
]
```

### 3. **`GET /organizations`**
todas las organizaciones y la lista de usuarios que estan dentro de las mismas.
```bash
curl -X GET http://localhost:8080/organizations
```

```json
[
  {
    "id": 1,
    "name": "Veritone",
    "users": [
      {
        "id": 1,
        "name": "Guido",
        "surname": "Enrique",
        "email": "guidoenr4@gmail.com"
      }
    ]
  }
]
```

### 4. **`GET /counters`**
un mapa de contadores para cada endpoint disponible.
> *(el propio endpoint `/counters` tambien tiene un contador y es actualizado al actualizar la pagina)*

```bash
curl -X GET http://localhost:8080/counters
```
```json
{
  "/": 10,
  "/users": 5,
  "/counters": 2,
  "/organizations": 3
}
```

## DB Schema

El esquema de la base de datos contiene dos tablas principales: 

**Usuarios** y **Organizaciones**, con una relaci贸n de muchos a muchos entre ellas (*y obviamente la tabla intermedia para JOINS*)

```
users
-----------------------------------------------
| id | name  | surname  | email                |
-----------------------------------------------
| 1  | John   | Doe     | john.doe@example.com |
-----------------------------------------------
| 2  | Guido  | Enrique | guidoenr4@gmail.com  |
-----------------------------------------------
... and more..

organizations
--------------------
| id   | name      |
--------------------
| 1    | Veritone  |
--------------------
| 2    | Slingr    |
--------------------
... and more

user_organizations (generated by `gorm` many2many)
-----------------------------
| user_id | organization_id |
-----------------------------
| 1       | 1               |
-----------------------------
```

Las mismas son inicializadas al iniciar el container con data de ejemplo, valiendose de [init.sql](https://github.com/guidoenr/marvik-challenge/blob/master/init.sql).

## Testing
existe la capacidad de correr tests, haciendo:
```bash
make test
```

esto iniciara las pruebas y verificar谩 que todo funcione correctamente. 

> [!IMPORTANT]
> El server debe estar corriendo (`:8080`) para ejecutar las pruebas.
> dado que estas hacen request literales a los endpoints reales.
> (de todas formas los tests no se ejecutaran si la API no esta levantada)


#### Enunciado
```
Implementar una API en Golang que:

a) se comunique con una base de datos (a elecci贸n) que tenga una tabla de usuarios con por lo menos los campos nombre, apellido y mail del usuario

b) reciba un request que tenga filtros de b煤squeda sobre la tabla usuarios y devuelva la lista de usuarios que cumplen con el criterio de b煤squeda, paginando en el backend

c) reciba un request GET que obtenga el valor de un contador de veces que fue llamado alguno de los endpoints disponibles

d) cada 5 minutos incremente un segundo contador e imprima su valor a un log o consola

Compartir tambi茅n el esquema de la base de datos. Te pedimos que el c贸digo lo compartas con Github en un repositorio privado compartiendo el c贸digo al usuario PeopleMarvik o simplemente como archivos adjuntos. Dejar en el README instrucciones para correr la API localmente y/o en un server en producci贸n.

Nice to have:

Permitir que los usuarios puedan pertenecer a una o m煤ltiples organizaciones y en el request de b煤squeda de usuarios devolver la lista de organizaciones a las que pertenece el usuario
```